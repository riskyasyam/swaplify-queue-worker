require('dotenv').config();
const { Reader } = require('nsqjs');
const axios = require('axios');

const NSQ_TOPIC = process.env.NSQ_TOPIC || 'facefusion_jobs';
const NSQ_CHANNEL = process.env.NSQ_CHANNEL || 'facefusion_worker';
const NSQ_HOST = process.env.NSQ_HOST || '127.0.0.1';
const NSQ_PORT = process.env.NSQ_PORT || '4150';
const NEST_API_URL = process.env.NEST_API_URL || 'http://localhost:3000';
const WORKER_URL = process.env.WORKER_URL || 'http://127.0.0.1:8081/worker/facefusion';
const WORKER_SECRET = process.env.WORKER_SHARED_SECRET || 'supersecret';
const INTERNAL_SECRET = process.env.INTERNAL_SECRET || 'internalsecret';

const reader = new Reader(NSQ_TOPIC, NSQ_CHANNEL, {
  nsqdTCPAddresses: `${NSQ_HOST}:${NSQ_PORT}`,
});

console.log('üöÄ Swaplify Queue Worker started. Waiting for jobs from NSQ...');
console.log(`üì° NSQ: ${NSQ_HOST}:${NSQ_PORT} | Topic: ${NSQ_TOPIC} | Channel: ${NSQ_CHANNEL}`);
console.log(`üîó NestJS: ${NEST_API_URL} | Worker: ${WORKER_URL}`);

reader.connect();

// Function to update job status to FAILED
async function updateJobToFailed(jobId, errorMessage) {
  try {
    await axios.post(`${NEST_API_URL}/jobs/${jobId}/internal-status`, {
      status: 'FAILED',
      progressPct: 0,
      errorMessage: errorMessage
    }, {
      headers: { 'X-Internal-Secret': INTERNAL_SECRET }
    });
    console.log(`‚ùå Job ${jobId} marked as FAILED`);
  } catch (err) {
    console.error(`‚ùå Failed to update job ${jobId} to FAILED:`, err.message);
  }
}

reader.on('message', async (msg) => {
  let job;
  try {
    job = JSON.parse(msg.body.toString());
    console.log(`üì® Received job from NSQ: jobId=${job.jobId}, sourceAssetId=${job.sourceAssetId}, targetAssetId=${job.targetAssetId}`);

    // Cek status job di NestJS
    let jobDetail;
    try {
      jobDetail = await axios.get(`${NEST_API_URL}/jobs/${job.jobId}`, {
        headers: { 'X-Internal-Secret': INTERNAL_SECRET }
      });
    } catch (err) {
      if (err?.response && (err.response.status === 401 || err.response.status === 404)) {
        console.error(`‚ùå Error fetching job detail: ${err.response.status} - requeue once`);
        msg.requeue(30000); // Retry once after 30s
        return;
      }
      throw err;
    }
    
    const status = jobDetail.data.status;
    if (status !== 'QUEUED' && status !== 'RUNNING') {
      console.log(`‚è© Job ${job.jobId} status is ${status}, skipping processing.`);
      msg.finish();
      return;
    }

    // Get asset details from NestJS API
    console.log(`üîÑ Fetching asset details for jobId=${job.jobId} from NestJS...`);
    const sourceAsset = await axios.get(`${NEST_API_URL}/media-assets/${job.sourceAssetId}`, {
      headers: { 'X-Internal-Secret': INTERNAL_SECRET }
    });
    const targetAsset = await axios.get(`${NEST_API_URL}/media-assets/${job.targetAssetId}`, {
      headers: { 'X-Internal-Secret': INTERNAL_SECRET }
    });

    // Build payload for FastAPI worker
    const payload = {
      jobId: job.jobId,
      sourceKey: sourceAsset.data.objectKey,
      targetKey: targetAsset.data.objectKey,
      options: {
        processors: job.processors || [],
        faceSwapperModel: job.options?.faceSwapperModel || 'inswapper_128',
        useCuda: job.options?.useCuda ?? true,
        deviceId: parseInt(job.options?.deviceId) || 0,
        extraArgs: []
      }
    };

    console.log(`üöÄ Sending job to FastAPI worker: jobId=${job.jobId}, payload=`, payload);
    
    // Update status ke RUNNING saat mulai kirim ke worker
    await axios.post(`${NEST_API_URL}/jobs/${job.jobId}/internal-status`, {
      status: 'RUNNING',
      progressPct: 10,
    }, {
      headers: { 'X-Internal-Secret': INTERNAL_SECRET }
    });
    console.log(`üîÑ Job status updated to RUNNING for jobId=${job.jobId}`);
    
    const response = await axios.post(WORKER_URL, payload, {
      headers: {
        'Content-Type': 'application/json',
        'X-Worker-Secret': WORKER_SECRET,
      },
    });

    console.log(`‚úÖ FastAPI worker response for jobId=${job.jobId}:`, response.data);
    console.log(`‚úÖ Job sent to worker, waiting for callback from FastAPI worker (jobId=${job.jobId})`);
    msg.finish();
    
  } catch (err) {
    console.error(`‚ùå Error processing job${job?.jobId ? ` (jobId=${job.jobId})` : ''}:`, err.message);
    if (err?.response) {
      console.error('‚ùå Error response data:', err.response.data);
      console.error('‚ùå Error response status:', err.response.status);
    }
    console.error('‚ùå Full error stack:', err.stack);
    
    // Update job to FAILED instead of requeue
    if (job?.jobId) {
      await updateJobToFailed(job.jobId, err.message);
    }
    
    msg.finish(); // Don't requeue, just finish
  }
});

reader.on('error', (err) => {
  console.error('NSQ Reader error:', err);
});

reader.on('discard', (msg) => {
  console.log('‚ö†Ô∏è Message discarded:', msg.body.toString());
});

reader.on('nsqd_connected', () => {
  console.log('‚úÖ Connected to NSQ');
});

reader.on('nsqd_closed', () => {
  console.log('‚ùå NSQ connection closed');
});